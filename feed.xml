<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://wert1229.github.io/</id><title>기록용</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2023-08-06T17:43:46+09:00</updated> <author> <name>박경덕</name> <uri>https://wert1229.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://wert1229.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en-US" href="https://wert1229.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator> <rights> © 2023 박경덕 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>JPA, DB가 일으킨 장애 해결 기록</title><link href="https://wert1229.github.io/posts/jpa-issue/" rel="alternate" type="text/html" title="JPA, DB가 일으킨 장애 해결 기록" /><published>2023-04-27T11:50:00+09:00</published> <updated>2023-04-27T11:50:00+09:00</updated> <id>https://wert1229.github.io/posts/jpa-issue/</id> <content src="https://wert1229.github.io/posts/jpa-issue/" /> <author> <name>박경덕</name> </author> <category term="경험" /> <category term="트러블슈팅" /> <summary> 상황 MSA 구조로 서버 간 HTTP 통신을 하고 있음. 레거시 모놀리틱 구조에서 MSA 로 전환 중에 있어서 서버는 분리되어 있으나 실제 DB는 하나로 쓰고 있는 상황 발단 설명하기 위해 자식 부모 관계인 책(Book) 도메인과 작가(Author) 도메인으로 예시를 들자면, 이런 구조의 API가 있었다. 발생한 문제는 해당 API의 Author Update 동작에서 DB timeout이 떨어진다는 것. 파악 기존에 잘 돌고 있던 API라 최초 알럿이 날라 왔을 땐 네트워크 상의 일시적 장애일 것이라 생각했으나 로그 확인 결과 같은 요청, 에러가 2번 연속으로 온 것을 확인, 누군가 어드민에서 시도했다가 실패해서 재시도한 것으로 판단. 원인 분석을 위해 일단 로그와 같은 ... </summary> </entry> <entry><title>1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence</title><link href="https://wert1229.github.io/posts/leetcode-1455/" rel="alternate" type="text/html" title="1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence" /><published>2021-03-28T15:36:00+09:00</published> <updated>2021-03-28T15:36:00+09:00</updated> <id>https://wert1229.github.io/posts/leetcode-1455/</id> <content src="https://wert1229.github.io/posts/leetcode-1455/" /> <author> <name>박경덕</name> </author> <category term="문제풀이" /> <category term="LeetCode" /> <summary> 문제 요약 공백으로 연걸된 문장의 단어 중 주어진 Prefix가 포함된 단어를 찾고 몇번째 위치한 단어인지 찾기 쉬운 문제라 푸는 것 자체는 어렵지 않다. 당장 떠오르는 가장 쉬운 방법은 1. 공백을 기준으로 split해서 풀기 int isPrefixOfWord(String sentence, String searchWord) { String[] arr = sentence.split(" "); for (int i = 0; i &amp;lt; arr.length; i++) { if (arr[i].startsWith(searchWord)) { return i + 1; } } return -1; } 2. 유사 KMP... </summary> </entry> <entry><title>Unsigned 정수</title><link href="https://wert1229.github.io/posts/java-unsigned/" rel="alternate" type="text/html" title="Unsigned 정수" /><published>2021-03-02T17:32:00+09:00</published> <updated>2023-08-06T17:07:08+09:00</updated> <id>https://wert1229.github.io/posts/java-unsigned/</id> <content src="https://wert1229.github.io/posts/java-unsigned/" /> <author> <name>박경덕</name> </author> <category term="언어" /> <category term="Java" /> <summary> 자바는 char를 제외하면 unsigned 정수타입을 지원하지 않는다. 그로 인해 발생하는 문제가 크게 2개가 있다. 1. 음수가 될 수 없는 값에 대해 한번 더 체크해줘야함. if (age &amp;lt; 0) { // do something } 나이가 음수가 될 일은 존재하지 않으므로 애초에 unsigned int를 쓰면 불필요한 검증을 생략할 수 있다. 하지만 반대로 unsigned int는 int age = 0; age--; saveAge(age); 라는 상황에서 값이 오버플로우 됨에 따라 이상한 값이 들어가게 될텐데 이걸 걸러줄 기준이 애매해진다.. 이때는 “나이가 몇 살 이하일 경우”로 체킹해야하는가? 그걸 몇 살로 할지, 나이가 아니라 금액이라면? 반대로 signed ... </summary> </entry> <entry><title>1356. Sort Integers by The Number of 1 Bits</title><link href="https://wert1229.github.io/posts/leetcode-1356/" rel="alternate" type="text/html" title="1356. Sort Integers by The Number of 1 Bits" /><published>2021-03-02T10:54:00+09:00</published> <updated>2021-05-16T02:06:06+09:00</updated> <id>https://wert1229.github.io/posts/leetcode-1356/</id> <content src="https://wert1229.github.io/posts/leetcode-1356/" /> <author> <name>박경덕</name> </author> <category term="문제풀이" /> <category term="LeetCode" /> <summary> 문제 요약 주어진 integer 배열을 비트1의 개수 오름차순으로 정렬하기 비트1의 개수를 세는 방법만 찾으면 된다. 1. 2로 나누기 2로 나누어서 나머지가 1이면 맨끝 비트가 1인 것이므로 개수를 더해주면 된다. 숫자가 0이 될 때까지 반복하면 된다. int countBits(int num) { int count = 0; while (num != 0) { count += num % 2; num /= 2; } return count; } 2. 비트 시프트로 구하기 2로 나누는 행위는 비트 시프트 연산으로 좀 더 빠르게 수행할 수 있다. 숫자를 “1”과 AND연산해서 1이면 끝 비트가 1이다. int countBits(int ... </summary> </entry> </feed>
